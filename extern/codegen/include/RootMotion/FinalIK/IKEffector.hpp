// Autogenerated from CppHeaderCreator
// Created by Sc2ad
// =========================================================================
#pragma once
// Begin includes
#include "extern/beatsaber-hook/shared/utils/typedefs.h"
// Including type: UnityEngine.Vector3
#include "UnityEngine/Vector3.hpp"
// Including type: UnityEngine.Quaternion
#include "UnityEngine/Quaternion.hpp"
// Including type: RootMotion.FinalIK.IKSolver
#include "RootMotion/FinalIK/IKSolver.hpp"
#include "extern/beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
#include "extern/beatsaber-hook/shared/utils/il2cpp-utils-properties.hpp"
#include "extern/beatsaber-hook/shared/utils/il2cpp-utils-fields.hpp"
#include "extern/beatsaber-hook/shared/utils/utils.h"
// Completed includes
// Begin forward declares
// Forward declaring namespace: UnityEngine
namespace UnityEngine {
  // Forward declaring type: Transform
  class Transform;
}
// Forward declaring namespace: RootMotion::FinalIK
namespace RootMotion::FinalIK {
  // Forward declaring type: IKSolverFullBody
  class IKSolverFullBody;
}
// Completed forward declares
// Type namespace: RootMotion.FinalIK
namespace RootMotion::FinalIK {
  // Size: 0xF0
  #pragma pack(push, 1)
  // Autogenerated type: RootMotion.FinalIK.IKEffector
  // [] Offset: FFFFFFFF
  class IKEffector : public ::Il2CppObject {
    public:
    // public UnityEngine.Transform bone
    // Size: 0x8
    // Offset: 0x10
    UnityEngine::Transform* bone;
    // Field size check
    static_assert(sizeof(UnityEngine::Transform*) == 0x8);
    // public UnityEngine.Transform target
    // Size: 0x8
    // Offset: 0x18
    UnityEngine::Transform* target;
    // Field size check
    static_assert(sizeof(UnityEngine::Transform*) == 0x8);
    // [RangeAttribute] Offset: 0xD28A38
    // public System.Single positionWeight
    // Size: 0x4
    // Offset: 0x20
    float positionWeight;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // [RangeAttribute] Offset: 0xD28A50
    // public System.Single rotationWeight
    // Size: 0x4
    // Offset: 0x24
    float rotationWeight;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public UnityEngine.Vector3 position
    // Size: 0xC
    // Offset: 0x28
    UnityEngine::Vector3 position;
    // Field size check
    static_assert(sizeof(UnityEngine::Vector3) == 0xC);
    // public UnityEngine.Quaternion rotation
    // Size: 0x10
    // Offset: 0x34
    UnityEngine::Quaternion rotation;
    // Field size check
    static_assert(sizeof(UnityEngine::Quaternion) == 0x10);
    // public UnityEngine.Vector3 positionOffset
    // Size: 0xC
    // Offset: 0x44
    UnityEngine::Vector3 positionOffset;
    // Field size check
    static_assert(sizeof(UnityEngine::Vector3) == 0xC);
    // [CompilerGeneratedAttribute] Offset: 0xD28A68
    // private System.Boolean <isEndEffector>k__BackingField
    // Size: 0x1
    // Offset: 0x50
    bool isEndEffector;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // public System.Boolean effectChildNodes
    // Size: 0x1
    // Offset: 0x51
    bool effectChildNodes;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: effectChildNodes and: maintainRelativePositionWeight
    char __padding8[0x2] = {};
    // [RangeAttribute] Offset: 0xD28A78
    // public System.Single maintainRelativePositionWeight
    // Size: 0x4
    // Offset: 0x54
    float maintainRelativePositionWeight;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // public UnityEngine.Transform[] childBones
    // Size: 0x8
    // Offset: 0x58
    ::Array<UnityEngine::Transform*>* childBones;
    // Field size check
    static_assert(sizeof(::Array<UnityEngine::Transform*>*) == 0x8);
    // public UnityEngine.Transform planeBone1
    // Size: 0x8
    // Offset: 0x60
    UnityEngine::Transform* planeBone1;
    // Field size check
    static_assert(sizeof(UnityEngine::Transform*) == 0x8);
    // public UnityEngine.Transform planeBone2
    // Size: 0x8
    // Offset: 0x68
    UnityEngine::Transform* planeBone2;
    // Field size check
    static_assert(sizeof(UnityEngine::Transform*) == 0x8);
    // public UnityEngine.Transform planeBone3
    // Size: 0x8
    // Offset: 0x70
    UnityEngine::Transform* planeBone3;
    // Field size check
    static_assert(sizeof(UnityEngine::Transform*) == 0x8);
    // public UnityEngine.Quaternion planeRotationOffset
    // Size: 0x10
    // Offset: 0x78
    UnityEngine::Quaternion planeRotationOffset;
    // Field size check
    static_assert(sizeof(UnityEngine::Quaternion) == 0x10);
    // private System.Single posW
    // Size: 0x4
    // Offset: 0x88
    float posW;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private System.Single rotW
    // Size: 0x4
    // Offset: 0x8C
    float rotW;
    // Field size check
    static_assert(sizeof(float) == 0x4);
    // private UnityEngine.Vector3[] localPositions
    // Size: 0x8
    // Offset: 0x90
    ::Array<UnityEngine::Vector3>* localPositions;
    // Field size check
    static_assert(sizeof(::Array<UnityEngine::Vector3>*) == 0x8);
    // private System.Boolean usePlaneNodes
    // Size: 0x1
    // Offset: 0x98
    bool usePlaneNodes;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: usePlaneNodes and: animatedPlaneRotation
    char __padding18[0x3] = {};
    // private UnityEngine.Quaternion animatedPlaneRotation
    // Size: 0x10
    // Offset: 0x9C
    UnityEngine::Quaternion animatedPlaneRotation;
    // Field size check
    static_assert(sizeof(UnityEngine::Quaternion) == 0x10);
    // private UnityEngine.Vector3 animatedPosition
    // Size: 0xC
    // Offset: 0xAC
    UnityEngine::Vector3 animatedPosition;
    // Field size check
    static_assert(sizeof(UnityEngine::Vector3) == 0xC);
    // private System.Boolean firstUpdate
    // Size: 0x1
    // Offset: 0xB8
    bool firstUpdate;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Padding between fields: firstUpdate and: chainIndex
    char __padding21[0x3] = {};
    // private System.Int32 chainIndex
    // Size: 0x4
    // Offset: 0xBC
    int chainIndex;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // private System.Int32 nodeIndex
    // Size: 0x4
    // Offset: 0xC0
    int nodeIndex;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // private System.Int32 plane1ChainIndex
    // Size: 0x4
    // Offset: 0xC4
    int plane1ChainIndex;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // private System.Int32 plane1NodeIndex
    // Size: 0x4
    // Offset: 0xC8
    int plane1NodeIndex;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // private System.Int32 plane2ChainIndex
    // Size: 0x4
    // Offset: 0xCC
    int plane2ChainIndex;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // private System.Int32 plane2NodeIndex
    // Size: 0x4
    // Offset: 0xD0
    int plane2NodeIndex;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // private System.Int32 plane3ChainIndex
    // Size: 0x4
    // Offset: 0xD4
    int plane3ChainIndex;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // private System.Int32 plane3NodeIndex
    // Size: 0x4
    // Offset: 0xD8
    int plane3NodeIndex;
    // Field size check
    static_assert(sizeof(int) == 0x4);
    // Padding between fields: plane3NodeIndex and: childChainIndexes
    char __padding29[0x4] = {};
    // private System.Int32[] childChainIndexes
    // Size: 0x8
    // Offset: 0xE0
    ::Array<int>* childChainIndexes;
    // Field size check
    static_assert(sizeof(::Array<int>*) == 0x8);
    // private System.Int32[] childNodeIndexes
    // Size: 0x8
    // Offset: 0xE8
    ::Array<int>* childNodeIndexes;
    // Field size check
    static_assert(sizeof(::Array<int>*) == 0x8);
    // Creating value type constructor for type: IKEffector
    IKEffector(UnityEngine::Transform* bone_ = {}, UnityEngine::Transform* target_ = {}, float positionWeight_ = {}, float rotationWeight_ = {}, UnityEngine::Vector3 position_ = {}, UnityEngine::Quaternion rotation_ = {}, UnityEngine::Vector3 positionOffset_ = {}, bool isEndEffector_ = {}, bool effectChildNodes_ = {}, float maintainRelativePositionWeight_ = {}, ::Array<UnityEngine::Transform*>* childBones_ = {}, UnityEngine::Transform* planeBone1_ = {}, UnityEngine::Transform* planeBone2_ = {}, UnityEngine::Transform* planeBone3_ = {}, UnityEngine::Quaternion planeRotationOffset_ = {}, float posW_ = {}, float rotW_ = {}, ::Array<UnityEngine::Vector3>* localPositions_ = {}, bool usePlaneNodes_ = {}, UnityEngine::Quaternion animatedPlaneRotation_ = {}, UnityEngine::Vector3 animatedPosition_ = {}, bool firstUpdate_ = {}, int chainIndex_ = {}, int nodeIndex_ = {}, int plane1ChainIndex_ = {}, int plane1NodeIndex_ = {}, int plane2ChainIndex_ = {}, int plane2NodeIndex_ = {}, int plane3ChainIndex_ = {}, int plane3NodeIndex_ = {}, ::Array<int>* childChainIndexes_ = {}, ::Array<int>* childNodeIndexes_ = {}) noexcept : bone{bone_}, target{target_}, positionWeight{positionWeight_}, rotationWeight{rotationWeight_}, position{position_}, rotation{rotation_}, positionOffset{positionOffset_}, isEndEffector{isEndEffector_}, effectChildNodes{effectChildNodes_}, maintainRelativePositionWeight{maintainRelativePositionWeight_}, childBones{childBones_}, planeBone1{planeBone1_}, planeBone2{planeBone2_}, planeBone3{planeBone3_}, planeRotationOffset{planeRotationOffset_}, posW{posW_}, rotW{rotW_}, localPositions{localPositions_}, usePlaneNodes{usePlaneNodes_}, animatedPlaneRotation{animatedPlaneRotation_}, animatedPosition{animatedPosition_}, firstUpdate{firstUpdate_}, chainIndex{chainIndex_}, nodeIndex{nodeIndex_}, plane1ChainIndex{plane1ChainIndex_}, plane1NodeIndex{plane1NodeIndex_}, plane2ChainIndex{plane2ChainIndex_}, plane2NodeIndex{plane2NodeIndex_}, plane3ChainIndex{plane3ChainIndex_}, plane3NodeIndex{plane3NodeIndex_}, childChainIndexes{childChainIndexes_}, childNodeIndexes{childNodeIndexes_} {}
    // public RootMotion.FinalIK.IKSolver/Node GetNode(RootMotion.FinalIK.IKSolverFullBody solver)
    // Offset: 0x1AFAFEC
    RootMotion::FinalIK::IKSolver::Node* GetNode(RootMotion::FinalIK::IKSolverFullBody* solver);
    // public System.Boolean get_isEndEffector()
    // Offset: 0x1AFB054
    bool get_isEndEffector();
    // private System.Void set_isEndEffector(System.Boolean value)
    // Offset: 0x1AFB05C
    void set_isEndEffector(bool value);
    // public System.Void PinToBone(System.Single positionWeight, System.Single rotationWeight)
    // Offset: 0x1AFB068
    void PinToBone(float positionWeight, float rotationWeight);
    // public System.Void .ctor(UnityEngine.Transform bone, UnityEngine.Transform[] childBones)
    // Offset: 0x1AFB2A8
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static IKEffector* New_ctor(UnityEngine::Transform* bone, ::Array<UnityEngine::Transform*>* childBones) {
      static auto ___internal__logger = ::Logger::get().WithContext("RootMotion::FinalIK::IKEffector::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<IKEffector*, creationType>(bone, childBones)));
    }
    // public System.Boolean IsValid(RootMotion.FinalIK.IKSolver solver, ref System.String message)
    // Offset: 0x1AFB450
    bool IsValid(RootMotion::FinalIK::IKSolver* solver, ::Il2CppString*& message);
    // public System.Void Initiate(RootMotion.FinalIK.IKSolverFullBody solver)
    // Offset: 0x1AFB74C
    void Initiate(RootMotion::FinalIK::IKSolverFullBody* solver);
    // public System.Void ResetOffset(RootMotion.FinalIK.IKSolverFullBody solver)
    // Offset: 0x1AFBA24
    void ResetOffset(RootMotion::FinalIK::IKSolverFullBody* solver);
    // public System.Void SetToTarget()
    // Offset: 0x1AFBB64
    void SetToTarget();
    // public System.Void OnPreSolve(RootMotion.FinalIK.IKSolverFullBody solver)
    // Offset: 0x1AFBC10
    void OnPreSolve(RootMotion::FinalIK::IKSolverFullBody* solver);
    // public System.Void OnPostWrite()
    // Offset: 0x1AFC264
    void OnPostWrite();
    // private UnityEngine.Quaternion GetPlaneRotation(RootMotion.FinalIK.IKSolverFullBody solver)
    // Offset: 0x1AFC2D4
    UnityEngine::Quaternion GetPlaneRotation(RootMotion::FinalIK::IKSolverFullBody* solver);
    // public System.Void Update(RootMotion.FinalIK.IKSolverFullBody solver)
    // Offset: 0x1AFC4EC
    void Update(RootMotion::FinalIK::IKSolverFullBody* solver);
    // private UnityEngine.Vector3 GetPosition(RootMotion.FinalIK.IKSolverFullBody solver, out UnityEngine.Quaternion planeRotationOffset)
    // Offset: 0x1AFC834
    UnityEngine::Vector3 GetPosition(RootMotion::FinalIK::IKSolverFullBody* solver, UnityEngine::Quaternion& planeRotationOffset);
    // public System.Void .ctor()
    // Offset: 0x1AFB13C
    // Implemented from: System.Object
    // Base method: System.Void Object::.ctor()
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static IKEffector* New_ctor() {
      static auto ___internal__logger = ::Logger::get().WithContext("RootMotion::FinalIK::IKEffector::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<IKEffector*, creationType>()));
    }
  }; // RootMotion.FinalIK.IKEffector
  #pragma pack(pop)
  static check_size<sizeof(IKEffector), 232 + sizeof(::Array<int>*)> __RootMotion_FinalIK_IKEffectorSizeCheck;
  static_assert(sizeof(IKEffector) == 0xF0);
}
DEFINE_IL2CPP_ARG_TYPE(RootMotion::FinalIK::IKEffector*, "RootMotion.FinalIK", "IKEffector");
