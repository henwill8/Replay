// Autogenerated from CppHeaderCreator
// Created by Sc2ad
// =========================================================================
#pragma once
// Begin includes
#include "extern/beatsaber-hook/shared/utils/typedefs.h"
// Including type: MasterServer.MessageHandler
#include "MasterServer/MessageHandler.hpp"
#include "extern/beatsaber-hook/shared/utils/il2cpp-utils-methods.hpp"
#include "extern/beatsaber-hook/shared/utils/il2cpp-utils-properties.hpp"
#include "extern/beatsaber-hook/shared/utils/il2cpp-utils-fields.hpp"
#include "extern/beatsaber-hook/shared/utils/utils.h"
// Completed includes
// Begin forward declares
// Forward declaring namespace: MasterServer
namespace MasterServer {
  // Forward declaring type: IAnalyticsManager
  class IAnalyticsManager;
  // Forward declaring type: IMasterServerReliableRequest
  class IMasterServerReliableRequest;
  // Forward declaring type: IMasterServerReliableResponse
  class IMasterServerReliableResponse;
  // Forward declaring type: IMasterServerAuthenticateRequest
  class IMasterServerAuthenticateRequest;
  // Forward declaring type: IHandshakeMessage
  class IHandshakeMessage;
}
// Forward declaring namespace: GlobalNamespace
namespace GlobalNamespace {
  // Forward declaring type: MasterServerEndPoint
  class MasterServerEndPoint;
  // Forward declaring type: PacketEncryptionLayer
  class PacketEncryptionLayer;
}
// Forward declaring namespace: System::Threading::Tasks
namespace System::Threading::Tasks {
  // Forward declaring type: Task
  class Task;
  // Forward declaring type: Task`1<TResult>
  template<typename TResult>
  class Task_1;
}
// Forward declaring namespace: System::Security::Authentication
namespace System::Security::Authentication {
  // Forward declaring type: AuthenticationException
  class AuthenticationException;
}
// Forward declaring namespace: LiteNetLib::Utils
namespace LiteNetLib::Utils {
  // Forward declaring type: NetDataWriter
  class NetDataWriter;
}
// Forward declaring namespace: System::Net
namespace System::Net {
  // Forward declaring type: IPEndPoint
  class IPEndPoint;
}
// Forward declaring namespace: System::Security::Cryptography::X509Certificates
namespace System::Security::Cryptography::X509Certificates {
  // Forward declaring type: X509Certificate2
  class X509Certificate2;
}
// Completed forward declares
// Type namespace: MasterServer
namespace MasterServer {
  // Size: 0x99
  #pragma pack(push, 1)
  // Autogenerated type: MasterServer.BaseClientMessageHandler
  // [] Offset: FFFFFFFF
  class BaseClientMessageHandler : public MasterServer::MessageHandler {
    public:
    // Nested type: MasterServer::BaseClientMessageHandler::$SendAuthenticatedRequest$d__17
    struct $SendAuthenticatedRequest$d__17;
    // Nested type: MasterServer::BaseClientMessageHandler::$SendAuthenticatedRequestAsync$d__18_1<T>
    template<typename T>
    struct $SendAuthenticatedRequestAsync$d__18_1;
    // Nested type: MasterServer::BaseClientMessageHandler::$SendAuthenticatedRequestAsync$d__19
    struct $SendAuthenticatedRequestAsync$d__19;
    // Nested type: MasterServer::BaseClientMessageHandler::$OnSendFailed$d__20
    struct $OnSendFailed$d__20;
    // Nested type: MasterServer::BaseClientMessageHandler::$OnSendFailedAwaitResponse$d__21_1<T>
    template<typename T>
    struct $OnSendFailedAwaitResponse$d__21_1;
    // Nested type: MasterServer::BaseClientMessageHandler::$ReauthenticateWithMasterServer$d__22
    struct $ReauthenticateWithMasterServer$d__22;
    // Nested type: MasterServer::BaseClientMessageHandler::$AuthenticateWithMasterServer$d__25
    struct $AuthenticateWithMasterServer$d__25;
    // Nested type: MasterServer::BaseClientMessageHandler::$AuthenticateWithMasterServerAsyncInternalVerbose$d__26
    struct $AuthenticateWithMasterServerAsyncInternalVerbose$d__26;
    // Nested type: MasterServer::BaseClientMessageHandler::$$c__DisplayClass27_0
    class $$c__DisplayClass27_0;
    // Nested type: MasterServer::BaseClientMessageHandler::$AuthenticateWithMasterServerAsyncInternal$d__27
    struct $AuthenticateWithMasterServerAsyncInternal$d__27;
    // Nested type: MasterServer::BaseClientMessageHandler::$$c__DisplayClass30_0
    class $$c__DisplayClass30_0;
    // private readonly MasterServerEndPoint _endPoint
    // Size: 0x8
    // Offset: 0x80
    GlobalNamespace::MasterServerEndPoint* endPoint;
    // Field size check
    static_assert(sizeof(GlobalNamespace::MasterServerEndPoint*) == 0x8);
    // private System.Threading.Tasks.Task _authenticationTask
    // Size: 0x8
    // Offset: 0x88
    System::Threading::Tasks::Task* authenticationTask;
    // Field size check
    static_assert(sizeof(System::Threading::Tasks::Task*) == 0x8);
    // private System.Security.Authentication.AuthenticationException _authenticationException
    // Size: 0x8
    // Offset: 0x90
    System::Security::Authentication::AuthenticationException* authenticationException;
    // Field size check
    static_assert(sizeof(System::Security::Authentication::AuthenticationException*) == 0x8);
    // private System.Boolean _disposed
    // Size: 0x1
    // Offset: 0x98
    bool disposed;
    // Field size check
    static_assert(sizeof(bool) == 0x1);
    // Creating value type constructor for type: BaseClientMessageHandler
    BaseClientMessageHandler(GlobalNamespace::MasterServerEndPoint* endPoint_ = {}, System::Threading::Tasks::Task* authenticationTask_ = {}, System::Security::Authentication::AuthenticationException* authenticationException_ = {}, bool disposed_ = {}) noexcept : endPoint{endPoint_}, authenticationTask{authenticationTask_}, authenticationException{authenticationException_}, disposed{disposed_} {}
    // [ThreadStaticAttribute] Offset: 0xD1C06C
    // Get static field: static private LiteNetLib.Utils.NetDataWriter _authenticationDataWriter
    static LiteNetLib::Utils::NetDataWriter* _get__authenticationDataWriter();
    // Set static field: static private LiteNetLib.Utils.NetDataWriter _authenticationDataWriter
    static void _set__authenticationDataWriter(LiteNetLib::Utils::NetDataWriter* value);
    // public MasterServerEndPoint get_endPoint()
    // Offset: 0x11DA09C
    GlobalNamespace::MasterServerEndPoint* get_endPoint();
    // public System.Boolean get_isAuthenticated()
    // Offset: 0x11DA0A4
    bool get_isAuthenticated();
    // public System.Boolean get_isAuthenticating()
    // Offset: 0x11DA12C
    bool get_isAuthenticating();
    // public System.Boolean get_hasAuthenticationFailed()
    // Offset: 0x11DA194
    bool get_hasAuthenticationFailed();
    // static private System.Void NoDomainReloadInit()
    // Offset: 0x11DA1A4
    static void NoDomainReloadInit();
    // protected System.Void .ctor(MasterServer.MessageHandler/IMessageSender sender, PacketEncryptionLayer encryptionLayer, MasterServerEndPoint endPoint, MasterServer.IAnalyticsManager analytics)
    // Offset: 0x11DA1F8
    template<::il2cpp_utils::CreationType creationType = ::il2cpp_utils::CreationType::Temporary>
    static BaseClientMessageHandler* New_ctor(MasterServer::MessageHandler::IMessageSender* sender, GlobalNamespace::PacketEncryptionLayer* encryptionLayer, GlobalNamespace::MasterServerEndPoint* endPoint, MasterServer::IAnalyticsManager* analytics) {
      static auto ___internal__logger = ::Logger::get().WithContext("MasterServer::BaseClientMessageHandler::.ctor");
      return THROW_UNLESS((::il2cpp_utils::New<BaseClientMessageHandler*, creationType>(sender, encryptionLayer, endPoint, analytics)));
    }
    // protected System.Void SendAuthenticatedRequest(MasterServer.IMasterServerReliableRequest message, System.Threading.CancellationToken cancellationToken)
    // Offset: 0x11DA29C
    void SendAuthenticatedRequest(MasterServer::IMasterServerReliableRequest* message, System::Threading::CancellationToken cancellationToken);
    // protected System.Threading.Tasks.Task`1<T> SendAuthenticatedRequestAsync(MasterServer.IMasterServerReliableRequest message, System.Threading.CancellationToken cancellationToken)
    // Offset: 0xFFFFFFFF
    template<class T>
    System::Threading::Tasks::Task_1<T>* SendAuthenticatedRequestAsync(MasterServer::IMasterServerReliableRequest* message, System::Threading::CancellationToken cancellationToken) {
      static_assert(std::is_base_of_v<MasterServer::IMasterServerReliableResponse, std::remove_pointer_t<T>>);
      static auto ___internal__logger = ::Logger::get().WithContext("MasterServer::BaseClientMessageHandler::SendAuthenticatedRequestAsync");
      static auto* ___internal__method = THROW_UNLESS(::il2cpp_utils::FindMethod(this, "SendAuthenticatedRequestAsync", std::vector<Il2CppClass*>{il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}, ::il2cpp_utils::ExtractTypes(message, cancellationToken)));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}));
      return ::il2cpp_utils::RunMethodThrow<System::Threading::Tasks::Task_1<T>*, false>(this, ___generic__method, message, cancellationToken);
    }
    // protected System.Threading.Tasks.Task SendAuthenticatedRequestAsync(MasterServer.IMasterServerReliableRequest message, System.Threading.CancellationToken cancellationToken)
    // Offset: 0x11DA39C
    System::Threading::Tasks::Task* SendAuthenticatedRequestAsync(MasterServer::IMasterServerReliableRequest* message, System::Threading::CancellationToken cancellationToken);
    // private System.Threading.Tasks.Task OnSendFailed(System.UInt32 protocolVersion, System.Net.IPEndPoint remoteEndPoint, MasterServer.IMasterServerReliableRequest message, System.Threading.CancellationToken cancellationToken)
    // Offset: 0x11DA4F0
    System::Threading::Tasks::Task* OnSendFailed(uint protocolVersion, System::Net::IPEndPoint* remoteEndPoint, MasterServer::IMasterServerReliableRequest* message, System::Threading::CancellationToken cancellationToken);
    // private System.Threading.Tasks.Task`1<T> OnSendFailedAwaitResponse(System.UInt32 protocolVersion, System.Net.IPEndPoint remoteEndPoint, MasterServer.IMasterServerReliableRequest message, System.Threading.CancellationToken cancellationToken)
    // Offset: 0xFFFFFFFF
    template<class T>
    System::Threading::Tasks::Task_1<T>* OnSendFailedAwaitResponse(uint protocolVersion, System::Net::IPEndPoint* remoteEndPoint, MasterServer::IMasterServerReliableRequest* message, System::Threading::CancellationToken cancellationToken) {
      static_assert(std::is_base_of_v<MasterServer::IMasterServerReliableResponse, std::remove_pointer_t<T>>);
      static auto ___internal__logger = ::Logger::get().WithContext("MasterServer::BaseClientMessageHandler::OnSendFailedAwaitResponse");
      static auto* ___internal__method = THROW_UNLESS(::il2cpp_utils::FindMethod(this, "OnSendFailedAwaitResponse", std::vector<Il2CppClass*>{il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}, ::il2cpp_utils::ExtractTypes(protocolVersion, remoteEndPoint, message, cancellationToken)));
      static auto* ___generic__method = THROW_UNLESS(::il2cpp_utils::MakeGenericMethod(___internal__method, std::vector<Il2CppClass*>{il2cpp_utils::il2cpp_type_check::il2cpp_no_arg_class<T>::get()}));
      return ::il2cpp_utils::RunMethodThrow<System::Threading::Tasks::Task_1<T>*, false>(this, ___generic__method, protocolVersion, remoteEndPoint, message, cancellationToken);
    }
    // private System.Threading.Tasks.Task ReauthenticateWithMasterServer()
    // Offset: 0x11DA658
    System::Threading::Tasks::Task* ReauthenticateWithMasterServer();
    // protected System.Void UnauthenticateWithMasterServer()
    // Offset: 0x11DA760
    void UnauthenticateWithMasterServer();
    // private System.Threading.Tasks.Task AuthenticateWithMasterServerAsync()
    // Offset: 0x11DA7DC
    System::Threading::Tasks::Task* AuthenticateWithMasterServerAsync();
    // protected System.Void AuthenticateWithMasterServer()
    // Offset: 0x11DA9BC
    void AuthenticateWithMasterServer();
    // private System.Threading.Tasks.Task AuthenticateWithMasterServerAsyncInternalVerbose()
    // Offset: 0x11DAA98
    System::Threading::Tasks::Task* AuthenticateWithMasterServerAsyncInternalVerbose();
    // private System.Threading.Tasks.Task AuthenticateWithMasterServerAsyncInternal()
    // Offset: 0x11DA8A4
    System::Threading::Tasks::Task* AuthenticateWithMasterServerAsyncInternal();
    // protected System.Threading.Tasks.Task`1<MasterServer.IMasterServerAuthenticateRequest> GetAuthenticationRequest()
    // Offset: 0xFFFFFFFF
    System::Threading::Tasks::Task_1<MasterServer::IMasterServerAuthenticateRequest*>* GetAuthenticationRequest();
    // private System.Threading.Tasks.Task`1<System.Boolean> VerifySignature(System.Byte[] clientRandom, System.Byte[] serverRandom, System.Byte[] serverKey, System.Byte[] signature, System.Byte[][] certData)
    // Offset: 0x11DABE4
    System::Threading::Tasks::Task_1<bool>* VerifySignature(::Array<uint8_t>* clientRandom, ::Array<uint8_t>* serverRandom, ::Array<uint8_t>* serverKey, ::Array<uint8_t>* signature, ::Array<::Array<uint8_t>*>* certData);
    // protected System.Void ValidateCertificateChain(System.Security.Cryptography.X509Certificates.X509Certificate2 certificate, System.Byte[][] certificateChain)
    // Offset: 0xFFFFFFFF
    void ValidateCertificateChain(System::Security::Cryptography::X509Certificates::X509Certificate2* certificate, ::Array<::Array<uint8_t>*>* certificateChain);
    // private System.Void HandshakeLog(System.String message)
    // Offset: 0x11DAD40
    void HandshakeLog(::Il2CppString* message);
    // public override System.Void Dispose()
    // Offset: 0x11DA230
    // Implemented from: MasterServer.MessageHandler
    // Base method: System.Void MessageHandler::Dispose()
    void Dispose();
    // Creating proxy method: System_IDisposable_Dispose
    // Maps to method: Dispose
    void System_IDisposable_Dispose();
    // protected override System.Boolean ShouldHandleHandshakeMessage(MasterServer.IHandshakeMessage packet, MasterServer.MessageHandler/MessageOrigin origin)
    // Offset: 0x11DA240
    // Implemented from: MasterServer.MessageHandler
    // Base method: System.Boolean MessageHandler::ShouldHandleHandshakeMessage(MasterServer.IHandshakeMessage packet, MasterServer.MessageHandler/MessageOrigin origin)
    bool ShouldHandleHandshakeMessage(MasterServer::IHandshakeMessage* packet, MasterServer::MessageHandler::MessageOrigin origin);
    // protected override System.Boolean ShouldHandleMessageFromEndPoint(System.Net.IPEndPoint endPoint)
    // Offset: 0x11DABA0
    // Implemented from: MasterServer.MessageHandler
    // Base method: System.Boolean MessageHandler::ShouldHandleMessageFromEndPoint(System.Net.IPEndPoint endPoint)
    bool ShouldHandleMessageFromEndPoint(System::Net::IPEndPoint* endPoint);
  }; // MasterServer.BaseClientMessageHandler
  #pragma pack(pop)
  static check_size<sizeof(BaseClientMessageHandler), 152 + sizeof(bool)> __MasterServer_BaseClientMessageHandlerSizeCheck;
  static_assert(sizeof(BaseClientMessageHandler) == 0x99);
}
DEFINE_IL2CPP_ARG_TYPE(MasterServer::BaseClientMessageHandler*, "MasterServer", "BaseClientMessageHandler");
